import win32com.client as win32
from pathlib import Path

# ======= SETTINGS =======
# 1) Put your REAL full path here:
FILE_PATH = r"C:\Users\2031146\Documents\T&O_HC_30Nov25(BPM)_versionPython.xlsx"

# 2) Sheets where we filter raw data (NO pivots, NO 6.Trf)
RAW_SHEETS = [
    "1.HC Data",
    "2.NewJoiners",
    "3.Leavers",
    "4.JR",
    "5.FG",
    # "6.Trf"  # intentionally skipped
]

# 3) Sheets where we expect pivots
PIVOT_SHEETS = [
    "1.HC Pivot",
    "2.NewJoiners Pivot",
    "3.Leavers Pivot",
    "4.JR Pivot",
    "5.FG Pivot",
    "6.Trf Pivot",
]

# 4) Which MT Domains to keep
ALLOWED_DOMAINS = {"CIB", "WRB", "Functions"}

# Excel constants
xlUp = -4162
xlRowField = 1


def find_column(ws, header_name):
    """Return col index (1-based) where row 1 == header_name."""
    used = ws.UsedRange
    ncols = used.Columns.Count
    for col in range(1, ncols + 1):
        val = ws.Cells(1, col).Value
        if isinstance(val, str) and val.strip() == header_name:
            return col
    return None


def filter_raw_sheets(wb):
    """Keep only rows with allowed MT Domain values in RAW_SHEETS."""
    for sheet_name in RAW_SHEETS:
        ws = wb.Worksheets(sheet_name)
        print(f"[RAW] Processing sheet: {sheet_name}")

        mt_col = find_column(ws, "MT Domain")
        if not mt_col:
            print(f"   -> MT Domain column NOT found, skipping.")
            continue

        last_row = ws.Cells(ws.Rows.Count, mt_col).End(xlUp).Row
        deleted = 0

        # delete from bottom up so row numbers don't shift
        for row in range(last_row, 1, -1):
            val = ws.Cells(row, mt_col).Value
            if val not in ALLOWED_DOMAINS:
                ws.Rows(row).Delete()
                deleted += 1

        print(f"   -> Deleted {deleted} rows.")


def adjust_pivots(wb):
    """Refresh pivots & set MT Domain + MT-1 Domain as row fields."""
    for sheet_name in PIVOT_SHEETS:
        ws = wb.Worksheets(sheet_name)
        print(f"[PIVOT] Sheet: {sheet_name}")

        for pt in ws.PivotTables():
            print(f"   Pivot: {pt.Name}")
            pt.PivotCache().Refresh()
            pt.RefreshTable()

            # Ensure MT Domain row field
            try:
                pf_mt = pt.PivotFields("MT Domain")
                pf_mt.Orientation = xlRowField
                # position 1 (or keep existing position if already set)
                pf_mt.Position = 1
            except Exception:
                print("      -> MT Domain field missing in this pivot, skipping MT-1 Domain.")
                continue

            # Add MT-1 Domain right after MT Domain (if exists)
            try:
                pf_mt1 = pt.PivotFields("MT-1 Domain")
                pf_mt1.Orientation = xlRowField
                pf_mt1.Position = pf_mt.Position + 1
                print("      -> MT-1 Domain placed next to MT Domain.")
            except Exception:
                print("      -> MT-1 Domain field not found in this pivot.")


def main():
    src_path = Path(FILE_PATH)
    if not src_path.exists():
        raise FileNotFoundError(f"File not found: {src_path}")

    # New file name with suffix
    dst_path = src_path.with_name(src_path.stem + "_CIB_WRB_Functions.xlsx")

    # Start Excel in the background
    excel = win32.DispatchEx("Excel.Application")
    excel.Visible = False
    excel.DisplayAlerts = False

    print(f"Opening original: {src_path}")
    wb_src = excel.Workbooks.Open(str(src_path))

    # Make a copy on disk
    print(f"Saving copy as: {dst_path}")
    wb_src.SaveCopyAs(str(dst_path))
    wb_src.Close(SaveChanges=False)

    # Now work ONLY on the copy
    wb = excel.Workbooks.Open(str(dst_path))

    try:
        print("\n=== Filtering raw sheets ===")
        filter_raw_sheets(wb)

        print("\n=== Refreshing & adjusting pivots ===")
        # global refresh
        wb.RefreshAll()
        adjust_pivots(wb)

        wb.Save()
        print(f"\nDone. New filtered file ready:\n{dst_path}")

    finally:
        wb.Close(SaveChanges=True)
        excel.Quit()


if __name__ == "__main__":
    main()





